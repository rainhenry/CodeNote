/*******************************************************************************

	程序名称：C语言版本的简单稳定通信程序，英文名称为：Simple and Reliable Communication
	创建日期：20180517
	程序版本：REV 0.4
	设计编写：rainhenry
	
	版本修订：
		REV 0.1		20180517		创建程序
		REV 0.2		20180527		增加数据打包的前回调函数与后回调函数，用于多字节发送的硬件支持
		REV 0.3		20180604		修改用户发送函数的判断，当发送队列满，并且第一条还未发送成功的时候，插入失败，保持队列内容不变
		REV 0.4		20180607		增加设置包ID的功能，防止主机设备重启或者中断后，导致暂时性通信失败
									用户可以修改保存包ID结果的回调函数来保存本次包ID到非易失存储器中，以便下次调用
	
	设计目的和原理
		1、采用丢包重发的机制实现在不稳定硬件上的稳定传输
		2、全部代码采用C语言编写，并采用节约内存的方式设计，可以方便的移植到各种处理器平台上
		3、接收与发送部分完全独立，完全可以进行单方向的传输，以便节约代码量
		4、针对小容量的MCU设计，全部采用静态分配内存的方式处理
	
	设计说明：
		1、将数据以包的形式发送
		2、每一次发送理论上都应该收到一次应答
		3、每一对发送（或者叫请求）和应答都有一个唯一的递增序号，该序号在最大范围内循环
		4、序号的最大范围可以通过宏定义修改，一定要大于2
			过小的序号范围将会导致发送的数据无法接收
		5、拥有一个指定长度的包发送状态缓存，可用于计算通信信号质量，丢包重发等处理。该长度由宏定义。
		6、一对发送和应答的数据包ID在发送方有：
			在队列状态（发送函数已经把数据请求存入发送队列状态缓存里面了）
			已发送状态（处理程序已经执行发送，但还没有收到应答）
			已完成状态（已经收到接收方的应答，回复给接收方处理完成）
		6、一对发送和应答的数据包ID在接收方有：
			新收到的数据（数据已经送达，并存入缓存，但是用户程序还未处理）
			用户已处理完成（用户程序已经处理完成，此时完成一次包处理）
		7、每个包发送的结构体中有尝试发送次数，该次数和状态为主要的统计依据。统计信号状态的时候，以发送端的数据稳准。
		8、发送端的数据包处理为阻塞方式处理，即一个包没有发送成功并收到应答的时候，是不会发送下一个包的，这样可以避免各种通信问题
		9、发送与接收队列直到内容满了以后，才会从另一端进行清除操作
		10、发送数据的时候，需要将发送端的尝试次数也一同发送，而且每次都是以最新的尝试次数更新到接收方的缓存中，这样对于单项通信的应用，接收方也可以表示信号强度
			该信号强度分为两种，相对于同一个设备而言，有接收的信号质量，和发送的信号质量
		11、当接收方收到多次同一个ID的数据包的是，仅仅更新重试次数，而不会多次调用用户处理程序
		12、发送和接收部分在编写的时候分开
		13、信号质量的百分比计算方法是：成功的发送次数比上全部发送的次数的百分比
		14、用户可以通过导出函数分别查询发送和接收指定的包ID的包的状态。查询发送主要看是否投递成功。查询接收主要看是否有新数据未处理。
		15、当重试发送次数超过最大发送信息缓冲区成员数目的三倍的时候，将不再累加重试发送次数，但是重试发送依然进行
		16、为了兼容半双工通信的硬件场合，以及为了用户编程方便，应答数据中添加可选的应答数据段部分
		17、为了兼容特殊硬件，实际的发送代码全部由SRCom_SendProcess和SRCom_RecvProcess内部调用，其他中断内的函数内没有调用任何和硬件相关的代码。
			
	数据包处理流程
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------
		时间顺序序号		|	发送方															|		接收方
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------
		1				|	用户调用发送数据												  	|
		2				|	为发送数据包分配序号，并存入发送缓存，设置状态为【在队列状态】			|	
		3				|	SRCom处理程序处理该数据包，通过底层硬件进行发送，设置为【已发送状态】	 	|
		4				|																	|	收到新数据，将数据存入缓存，将该数据包设置为【新收到状态】
		5				|																	|	用户使用该数据进行处理
		6				|																	|	SRCom处理程序应答发送方，将该数据包设置为【用户已处理状态】
		7				|	SRCom收到应答，回复接收方数据包处理完成								|
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	发送处理状态机（每个已经存入发送缓存都有一个属于自己的状态）
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------
		状态值						处理内容												改变状态的控制权
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------
		0							用户已经将发送数据的请求放入，但是还没有执行发送			SRCom处理程序
		1							已经执行完成硬件发送，正在等待回应超时					接收中断程序（当超时的时候，不会改变状态，只会重新触发一次硬件发送，并且累计重试次数）
		2							在超时时间内成功收到回应								SRCom处理程序
		3							用户处理完成回应数据									结束该数据包
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	接收处理状态机（每个已经存入接收缓存都有一个属于自己的状态）
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------
		状态值						处理内容												改变状态的控制权
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------
		0							已经收到来自硬件的数据包，但是用户还未处理				回调函数，无需用户处理
		1							用户已经处理完成，正在发送回应							SRCom处理程序
		2							回应发送完成，该数据包处理完毕							已经完成该数据包的处理，当再次收到相同ID的请求的时候，会再次发送一次回应，但是不会调用用户程序处理
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------

	请求数据包结构
	-----------------------------------------------------------------------------------------------------
		结构	|	数据头		包ID			实际发送次数		用户数据长度			用户数据	   	校验
		内容	|   5A 12	  	[ID] 		[COUNT]			[LEN]				[DAT]		[C]
		长度	|	2		  	2			 2				4					[LEN]		1
	-----------------------------------------------------------------------------------------------------
		数据头			----	固定为 5A 12
		包ID				----	低字节在前，高字节在后。为每个包的唯一编号
		实际发送次数		----	为发送方实际发送请求包的次数,低字节在前，高字节在后
		用户数据长度	  	----	低字节在前，高字节在后，为后面[用户数据]的字节数目
		用户数据       	----	为用户自定义数据，该内容为必须的，也就是用户的数据长度至少为1
		校验			 	----	为了提高效率，这里采用“异或”运算，即从整个数据包的第一个字节到用户数据的最后一个字节的“异或”值
	
	应答数据包结构
	-------------------------------------------------------------------------------
		结构	|	数据头		包ID		用户数据长度		用户数据	  	校验
		内容	|   5A 34	  	[ID] 	[LEN]			[DAT] 		[C]
		长度	|	2		  	2		 4				[LEN]		 1
	------------------------------------------------------------------------------
		数据头			----	固定为 5A 12
		包ID		  	 	----	低字节在前，高字节在后。为每个包的唯一编号
		用户数据长度	  	----	低字节在前，高字节在后，为后面[用户数据]的字节数目
		用户数据       	----	为用户自定义数据，该内容为可选的，当用户数据的长度为0的时候，将没有此部分
		校验			 	----	为了提高效率，这里采用“异或”运算，即从整个数据包的第一个字节到用户数据的最后一个字节的“异或”值
	
*******************************************************************************/
//------------------------------------------------------------------------------
//	重定义保护
#ifndef __SRCOM_H__
#define __SRCOM_H__

//------------------------------------------------------------------------------
//	C++兼容处理
#ifdef __cplusplus
extern "C"
{
#endif
	
//------------------------------------------------------------------------------
//	定义相关
	
//	总体控制相关的宏
#define		SRCOM_USING_SEND				//	使用发送功能的宏，开启该宏后，所有与发送相关的处理都会参与编译
//#define		SRCOM_USING_RECV				//	使用接收功能的宏，开启该宏后，所有与接收相关的处理都会参与编译
	
//	与发送相关的宏
#define 	SRCOM_SEND_INFO_BUFF_SIZE		512		//	发送信息缓冲区大小，以字节为单位
#define 	SRCOM_MAX_ID					4096	//	定义最大包ID
#define 	SRCOM_RESEND_TIMEOUT			3		//	无回复重发超时，该值为发送处理的循环次数单位
#define 	SRCOM_SEND_ACK_RECV_BUFF_SIZE	256		//	定义发送部分的应答接收用户数据的缓冲区大小

//	与接收相关的宏
#define 	SRCOM_RECV_BUFF_SIZE 			256		//	接收部分的接收缓冲区大小
#define 	SRCOM_RECV_INFO_BUFF_SIZE		512		//	接收信息缓冲区大小，以字节为单位
	
//	定义发送结构的数据类型，32位CPU时为24字节
typedef struct tagSRCom_SSendInfo
{
	void* pUserData;						//	用户数据首地址
	int data_len;							//	用户数据长度
	int status;								//	处理状态
	int send_count;							//	实际发送次数
	int pack_id;							//	数据包的ID
}SRCom_SSendInfo;

//	定义接收结构的数据类型
typedef struct tagSRCom_SRecvInfo
{
	int status;								//	处理状态
	int send_count;							//	实际发送的次数
	int pack_id;							//	数据包的ID
}SRCom_SRecvInfo;
	
//------------------------------------------------------------------------------
//	导出函数	
//------------------------------------------------------------------------------
//	公共部分
#if defined(SRCOM_USING_SEND) || defined(SRCOM_USING_RECV)
//	接收处理
void SRCom_HARDWARE_ONRECV_ONE_BYTE(unsigned char in);
#endif	//	SRCOM_USING_SEND || SRCOM_USING_RECV
	
//------------------------------------------------------------------------------
//	发送部分
#ifdef SRCOM_USING_SEND		
//	提供给用户调用的发送数据，该函数只是将用户的请求放入发送信息队列中，并不直接操作底层硬件
void SRCom_UserSend(
	void* pdat,							//	用户数据首地址
	int len								//	用户数据长度	
	);
	
//	由用户调用的发送处理
void SRCom_SendProcess(void);

//	计算当前发送部分的信号质量百分比
int SRCom_GetSendSignalQualityPer(void);
	
//	设置包ID
void SRCom_SetPackID(int in);
	
#endif	//	SRCOM_USING_SEND

//------------------------------------------------------------------------------
//	接收部分
#ifdef SRCOM_USING_RECV
//	接收处理
void SRCom_RecvProcess(void);

//	接收部分的应答发送打包，该函数用户可以在SRCom_ONRECV_USER_DATA回调函数中调用处理返回的数据包
void SRCom_RecvPackOneSendAck(
	int id,							//	数据包的ID
	int len,						//	用户数据的长度
	void* pdat 						//	用户数据的首地址
	);

//	统计接收部分的信号质量百分比
int SRCom_GetRecvSignalQualityPer(void);

#endif	//	SRCOM_USING_RECV

//------------------------------------------------------------------------------
//	C++兼容处理
#ifdef __cplusplus
}
#endif
	
//------------------------------------------------------------------------------
#endif	//	__SRCOM_H__
